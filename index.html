<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0">
        <style>
            * {
                box-sizing: border-box;
                margin: 0;
                padding: 0;
            }

            html,
            body {
                height: 100%;
            }

            body {
                display: flex;
            }

            #container {
                display: flex;
                align-items: start;
                gap: .5rem;
                margin: auto;
            }

            #container canvas {
                touch-action: none;
            }

            #container .tp-rotv {
                width: 20rem;
            }
        </style>
    </head>

    <body>
        <div id="container">
            <canvas></canvas>
        </div>

        <script>
            const CANVAS_WIDTH = 512;
            const CANVAS_HEIGHT = 512;

            const controlOptions = {
                resolution: {
                    disabled: true,
                    min: 1,
                    max: 8,
                    step: 2,
                },
                pixelated: null,
                dt: {
                    min: .01,
                    max: 2,
                    step: .05,
                },
                dyeRadius: {
                    min: 2,
                    max: 16,
                    step: 2,
                },
                dyeFade: {
                    min: .9,
                    max: 1,
                    step: .001,
                },
                viscosity: {
                    min: .001,
                    max: .1,
                    step: .01
                },
                vorticity: {
                    min: .005,
                    max: .5,
                    step: .001,
                },
                diffusionIterations: {
                    min: 5,
                    max: 40,
                    step: 5,
                },
                pressureIterations: {
                    min: 5,
                    max: 40,
                    step: 5,
                },
            };

            const settings = {
                resolution: 8,
                pixelated: false,
                dt: .5,
                dyeRadius: 4,
                dyeFade: .995,
                viscosity: .001,
                vorticity: .25,
                diffusionIterations: 20,
                pressureIterations: 20,
            };
        </script>

        <script>
            const canvas = document.querySelector('canvas');

            canvas.width = Math.floor(CANVAS_WIDTH / settings.resolution);
            canvas.height = Math.floor(CANVAS_HEIGHT / settings.resolution);
            canvas.style.width = `${CANVAS_WIDTH}px`;
            canvas.style.height = `${CANVAS_HEIGHT}px`;

            const context = canvas.getContext('2d', { alpha: false });

            context.imageSmoothingEnabled = true;
            context.imageSmoothingQuality = 'high';

            const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
        </script>

        <script>
            function IX(x, y) {
                return x + y * canvas.width;
            }

            function int(value) {
                return value | 0;
            }

            function fract(value) {
                return value % 1;
            }

            function clamp(value, min, max) {
                return Math.max(min, Math.min(value, max));
            }

            function lerp(a, b, t) {
                return (1 - t) * a + t * b;
            }
        </script>

        <script type="module">
            import { Pane } from 'https://cdn.jsdelivr.net/npm/tweakpane@4.0.5/dist/tweakpane.min.js';

            const controls = new Map();
            const pane = new Pane({
                title: 'Settings',
                container: document.getElementById('container'),
            });

            Object.entries(settings).forEach(setting => {
                const [key, value] = setting;

                const options = controlOptions[key];
                const control = pane.addBinding(settings, key, options);

                controls.set(key, control);
            });

            controls.get('pixelated').on('change', (event) => {
                canvas.style.imageRendering = event.value ? 'pixelated' : 'auto';
            });

            let isPointerPressed = false;

            canvas.addEventListener('pointerdown', (event) => (isPointerPressed = true));
            canvas.addEventListener('pointerup', () => (isPointerPressed = false));
            canvas.addEventListener('pointermove', (event) => {
                if (!isPointerPressed) {
                    return;
                }

                const { offsetX, offsetY, movementX, movementY } = event;

                const pointerX = Math.floor(offsetX / settings.resolution);
                const pointerY = Math.floor(offsetY / settings.resolution);
                const movementLength = Math.hypot(movementX, movementY);

                const { dyeRadius, dt } = settings;

                for (let y = -dyeRadius; y < dyeRadius; y++) {
                    for (let x = -dyeRadius; x < dyeRadius; x++) {
                        const i = IX(pointerX + x, pointerY + y);

                        const length = Math.hypot(x, y);

                        if (length > dyeRadius) {
                            continue;
                        }

                        const velocityX = movementX / movementLength
                        const velocityY = movementY / movementLength;

                        dye0[i] = 1;
                        u0[i] = dt * velocityX;
                        v0[i] = dt * velocityY;
                    }
                }
            }, { passive: true });
        </script>

        <script>
            let bufferLength = canvas.width * canvas.height;

            let u0 = new Float32Array(bufferLength);
            let u1 = new Float32Array(bufferLength);
            let v0 = new Float32Array(bufferLength);
            let v1 = new Float32Array(bufferLength);
            let p0 = new Float32Array(bufferLength);
            let p1 = new Float32Array(bufferLength);     
            let div = new Float32Array(bufferLength);
            let vor = new Float32Array(bufferLength);
            let dye0 = new Float32Array(bufferLength);
            let dye1 = new Float32Array(bufferLength);
        </script>

        <script>
            function advect(u, v, q0, q1) {
                for (let y = 1; y < canvas.height - 1; y++) {
                    for (let x = 1; x < canvas.width - 1; x++) {
                        const i = IX(x, y);

                        const tx = clamp(x - settings.dt * u[i], 1, canvas.width - 1);
                        const ty = clamp(y - settings.dt * v[i], 1, canvas.height - 1);
                        const itx = int(tx);
                        const ity = int(ty);
                        const ftx = fract(tx);
                        const fty = fract(ty);

                        const L = itx;
                        const R = L + 1;
                        const T = ity;
                        const B = T + 1;

                        const TL = q0[IX(L, T)];
                        const TR = q0[IX(R, T)];
                        const BL = q0[IX(L, B)];
                        const BR = q0[IX(R, B)];

                        const lerpT = lerp(TL, TR, ftx);
                        const lerpB = lerp(BL, BR, ftx);

                        q1[i] = lerp(lerpT, lerpB, fty);
                    }
                }
            }

            function diverge(u, v, div) {
                for (let y = 1; y < canvas.height - 1; y++) {
                    for (let x = 1; x < canvas.width - 1; x++) {
                        const Ci = IX(x, y);
                        const Li = IX(x - 1, y);
                        const Ri = IX(x + 1, y);
                        const Ti = IX(x, y - 1);
                        const Bi = IX(x, y + 1);

                        const L = u[Li];
                        const R = u[Ri];
                        const T = v[Ti];
                        const B = v[Bi];

                        div[Ci] = (R - L + B - T) / 2;
                    }
                }
            }

            function poisson(x0, x1, b, al, bt) {
                for (let y = 1; y < canvas.height - 1; y++) {
                    for (let x = 1; x < canvas.width - 1; x++) {
                        const Ci = IX(x, y);
                        const Li = IX(x - 1, y);
                        const Ri = IX(x + 1, y);
                        const Ti = IX(x, y - 1);
                        const Bi = IX(x, y + 1);

                        const C = b[Ci];
                        const L = x0[Li];
                        const R = x0[Ri];
                        const T = x0[Ti];
                        const B = x0[Bi];

                        // Stams approach
                        x1[Ci] = (C + al * (L + R + T + B)) / bt;
                        // GPU Gems (NVidia) approach
                        // x1[Ci] = (L + R + T + B + al * C) / bt;
                    }
                }
            }

            function project(u, v, p) {
                for (let y = 1; y < canvas.height - 1; y++) {
                    for (let x = 1; x < canvas.width - 1; x++) {
                        const Ci = IX(x, y);
                        const Li = IX(x - 1, y);
                        const Ri = IX(x + 1, y);
                        const Ti = IX(x, y - 1);
                        const Bi = IX(x, y + 1);

                        const L = p[Li];
                        const R = p[Ri];
                        const T = p[Ti];
                        const B = p[Bi];

                        u[Ci] -= (R - L) / 2;
                        v[Ci] -= (B - T) / 2;
                    }
                }
            }

            function vorticity(u, v, vor) {
                for (let y = 1; y < canvas.height - 1; y++) {
                    for (let x = 1; x < canvas.width - 1; x++) {
                        const Ci = IX(x, y);
                        const Li = IX(x - 1, y);
                        const Ri = IX(x + 1, y);
                        const Ti = IX(x, y - 1);
                        const Bi = IX(x, y + 1);

                        const L = v[Li];
                        const R = v[Ri];
                        const T = u[Ti];
                        const B = u[Bi];

                        vor[Ci] = ((R - L) - (B - T)) / 2;
                    }
                }
            }

            function vorticityConfinement(u, v, vor) {
                for (let y = 1; y < canvas.height - 1; y++) {
                    for (let x = 1; x < canvas.width - 1; x++) {
                        const Ci = IX(x, y);
                        const Li = IX(x - 1, y);
                        const Ri = IX(x + 1, y);
                        const Ti = IX(x, y - 1);
                        const Bi = IX(x, y + 1);

                        const L = Math.abs(vor[Li]);
                        const R = Math.abs(vor[Ri]);
                        const T = Math.abs(vor[Ti]);
                        const B = Math.abs(vor[Bi]);

                        let gradX = (R - L) / 2;
                        let gradY = (B - T) / 2;
                        const gradLength = Math.max(1e-4, Math.hypot(gradX, gradY));

                        gradX /= gradLength;
                        gradY /= gradLength;

                        const force = settings.vorticity * vor[Ci];

                        u[Ci] += settings.dt * force * gradY;
                        v[Ci] -= settings.dt * force * gradX;
                    }
                }
            }

            function velocityBoundary(u, v) {
                for (let y = 0; y < canvas.height; y++) {
                    const L0i = IX(0, y);
                    const L1i = IX(1, y);
                    const R0i = IX(canvas.width - 1, y);
                    const R1i = IX(canvas.width - 2, y);

                    u[L0i] = -u[L1i];
                    u[R0i] = -u[R1i];
                }

                for (let x = 0; x < canvas.width; x++) {
                    const T0i = IX(x, 0);
                    const T1i = IX(x, 1);
                    const B0i = IX(x, canvas.height - 1);
                    const B1i = IX(x, canvas.height - 2);

                    v[T0i] = -v[T1i];
                    v[B0i] = -v[B1i];
                }
            }
        </script>

        <script>
            function simulate() {
                let temp;

                for (let i = 0; i < settings.diffusionIterations; i++) {
                    const al = settings.viscosity * settings.dt;
                    const bt = 1 + 4 * al;

                    poisson(u0, u1, u0, al, bt);
                    poisson(v0, v1, v0, al, bt);

                    temp = u0;
                    u0 = u1;
                    u1 = temp;

                    temp = v0;
                    v0 = v1;
                    v1 = temp;
                }

                advect(u0, v0, u0, u1);
                advect(u0, v0, v0, v1);

                temp = u0;
                u0 = u1;
                u1 = temp;

                temp = v0;
                v0 = v1;
                v1 = temp;

                velocityBoundary(u0, v0);

                diverge(u0, v0, div);

                p0.fill(0);

                for (let i = 0; i < settings.pressureIterations; i++) {
                    poisson(p0, p1, div, -1, -4);

                    temp = p0;
                    p0 = p1;
                    p1 = temp;
                }

                project(u0, v0, p0);

                vorticity(u0, v0, vor);
                vorticityConfinement(u0, v0, vor);

                velocityBoundary(u0, v0);

                advect(u0, v0, dye0, dye1);

                temp = dye0;
                dye0 = dye1;
                dye1 = temp;

                // for (let i = 0; i < DIFFUSION_ITERATIONS; i++) {
                //     const al = settings.viscosity * settings.dt;
                //     const bt = 1 + 4 * al;

                //     poisson(dye0, dye1, dye0, al, bt);

                //     temp = dye0;
                //     dye0 = dye1;
                //     dye1 = temp;
                // }

                for (let i = 0; i < dye0.length; i++) {
                    dye0[i] *= settings.dyeFade;
                }
            }

            function render(q) {
                for (let y = 1; y < canvas.height - 1; y++) {
                    for (let x = 1; x < canvas.width - 1; x++) {
                        const i = IX(x, y);
                        const pi = 4 * i;

                        const r = q[i];
                        const g = q[i];
                        const b = q[i];

                        imageData.data[pi + 0] = 255 * r;
                        imageData.data[pi + 1] = 255 * g;
                        imageData.data[pi + 2] = 255 * b;
                        imageData.data[pi + 3] = 255;
                    }
                }

                context.putImageData(imageData, 0, 0);
            }

            function loop() {
                simulate();
                render(dye0);

                requestAnimationFrame(loop);
            }

            requestAnimationFrame(loop);
        </script>
    </body>
</html>